<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32 Motor Control SDK: Speed &amp; position feedback sensorless algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }
});
</script>
<script type="text/javascript" async="async" src="./mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styleSheetFile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="motor_control.png"/></td>
  <td id="projectalign">
   <div id="projectname">STM32 Motor Control SDK<span id="projectnumber">&#160;MCFW-6.1.0</span>
   </div>
   <div id="projectbrief">Software Development Kit to build applications driving PMSM Motors with STM32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Speed &amp; position feedback sensorless algorithms </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Introduction</h1>
<p >The MCSDK firmware library provides a complete solution for the sensorless motor control.</p>
<p >The method is based on the motor Back-EMF estimation by using a Luenberger state observer combined with a phase detection algorithm (as seen in block diagrams below):</p>
<ol type="1">
<li>STate Observer (STO) based on Back-EMF observer</li>
<li>Phase detection algorithm. Two distinct methods to extract the angle are supported in mcsdk library:<ul>
<li>Phase Locked Loop (PLL)</li>
<li>CORDIC: providing the "atan" trigonometric function. <br  />
</li>
</ul>
</li>
</ol>
<div class="image">
<img src="STO_PLL_CORDIC.png" alt=""/>
<div class="caption">
STO PLL Schematic Bloc</div></div>
    <p >The measured currents \(i_{\alpha}\), \(i_{\beta}\) and the feeding voltages , \(v_{\alpha}\), \(v_{\beta}\) are used as input of state observer to estimate the motor back-EMF which contains the information on the rotor magnet position and therefore the speed according to the following statements:</p>
<p >\(\hat{E}_\alpha= |\hat{E}|\cos{\hat{\theta_r}}\)</p>
<p >\(\hat{E}_\beta=  -|\hat{E}|\sin{\hat{\theta_r}}\)</p>
<p >\(|\hat{E}| = \sqrt{\hat{E}_\alpha^2 + \hat{E}_\beta^2}\)</p>
<p >\({\hat{\theta_r}} = {\hat{\theta_{r0}}} + \int_{t_0}^t \mathrm{\hat{\omega_r}}(\tau)\,\mathrm{d}\tau\)</p>
<p >Where \(\hat{E}_\alpha\), \(\hat{E}_\beta\) represent estimated B-EMF of the motor and \( |\hat{E}| = K_e\hat{\omega}_r\) its amplitude.</p>
<p >\(\hat{\omega}_r\) and \(\hat{\theta_r}\) represent respectively the motor electrical speed and the associated electrical angle.</p>
<p >At each FOC period (in current loop control) the estimated B-EMF vector \({\hat{E}_{\alpha\beta}}\) must be processed by a phase-detection algorithm in order to extract the information of the rotor magnet position and speed. As described in the block diagrams the rotor speed parameter is also provided as a feedback signal to the STate Observer itself.</p>
<h1>Back-EMF STate Observer (STO)</h1>
<p >Starting from a motor model, a Luenberger-like observer is used to track the motor back-EMF. Then the position and speed information can be properly extracted through the use of a phase-detection algorithm.</p>
<div class="image">
<img src="STO_B_EMF_Observer.png" alt=""/>
<div class="caption">
STO Schematic Bloc</div></div>
    <p >Hence, the differential equations describing the back-EMF observer of the estimator presented in block diagram above can be stated as follows:</p>
<p >$$X′(t)=AX(t)+Bu(t)+K(y(t)-Y(t))$$</p>
<p >\(\frac{d\hat{I}_{\alpha,\beta}(t)}{dt}= - \frac{Rs}{Ls} \hat{I}_{\alpha,\beta}(t)- \frac{\hat{E}_{\alpha,\beta}(t)}{ Ls } + \frac{ v_{\alpha,\beta}(t)}{ Ls } + {\color{green}{K_1}} [i_{\alpha,\beta}(t) - \hat{I}_{\alpha,\beta}(t)] \)</p>
<p >\(\frac{d\hat{E_\alpha}(t)}{dt}=  \omega_r \hat{E_\beta}(t) + {\color{green}{K_2}} [i_\alpha (t)- \hat{I_\alpha}(t)] \)</p>
<p >\(\frac{d\hat{E_\beta}(t)}{dt}= -\omega_r \hat{E_\alpha}(t) + {\color{green}{K_2}}[i_\beta(t)- \hat{I_\beta}(t)] \)</p>
<p >To switch from continuous to discrete time, need to apply the sampling time period (specified as T)</p>
<ul>
<li><p class="startli">Expression of Estimated Currents:</p>
<p class="startli">\(\hat{I}_{\alpha,\beta}(n+1)-\hat{I}_{\alpha,\beta}(n) = -\frac{Rs }{ Ls }.T.\hat{I}_{\alpha,\beta}(n)- T.\frac{ \hat{E}_{\alpha,\beta}(n)}{ Ls } + T.\frac{ v_{\alpha,\beta}(n)}{ Ls } + {\color{green}{K_1}}.T.[i_{\alpha,\beta}(n) - \hat{I}_{\alpha,\beta}(n)] \)</p>
<p class="startli">\(\hat{I}_{\alpha,\beta}(n+1) = \hat{I}_{\alpha,\beta}(n) -\frac{Rs }{ Ls }.T.\hat{I}_{\alpha,\beta}(n)- T.\frac{ \hat{E}_{\alpha,\beta}(n)}{ Ls } + T.\frac{ v_{\alpha,\beta}(n)}{ Ls } + {\color{green}{K_1}}.T.[i_{\alpha,\beta}(n) - \hat{I}_{\alpha,\beta}(n)] \)</p>
<p class="startli">\(\hat{I}_{\alpha,\beta}(n+1) = \hat{I}_{\alpha,\beta}(n) - {\color{blue}{C_1}}.\hat{I}_{\alpha,\beta}(n)- {\color{blue}{C_3}}. \hat{E}_{\alpha,\beta}(n) + {\color{blue}{C_5}} .v_{\alpha,\beta}(n) + {{\color{green}{C_2}}}.[i_{\alpha,\beta}(n) - \hat{I}_{\alpha,\beta}(n)]\)</p>
</li>
</ul>
<p >Identification of constants \(\color{blue}{C_1, C_2, C_3, C_5}\) used in estimated currents:</p>
<p >\({\color{blue}{C_1}} = F_1.\frac{Rs }{ Ls }.T\)</p>
<p >\({\color{blue}{C_3}} =F_1.\frac{MAX\_BEMF\_VOLTAGE}{MAX\_CURRENT} \frac{T}{LS}\)</p>
<p >\({\color{blue}{C_5}} = F_1.\frac{MAX\_VOLTAGE}{MAX\_CURRENT}\frac{T}{LS}\)</p>
<p >and \({{\color{green}{C_2}}} = F1.{\color{green}{K_1}}.T\) : with \({{\color{green}{C_2}}}\) = <b>Gain1</b> computed by ST Motor Control Workbench in section "Speed Sensing / Observer".</p>
<ul>
<li><p class="startli">Expression of Estimated Back-EMF:</p>
<p class="startli">\(\hat{E_\alpha}(n+1) = \hat{E_\alpha}(n) + T.\omega_r .\hat{E_\beta}(n) + {\color{green}{K_2}}.T. [i_\alpha(n) - \hat{I_\alpha}(n)]\)</p>
<p class="startli">\(\hat{E_\beta}(n+1) = \hat{E_\beta}(n) - T.\omega_r .\hat{E_\alpha}(n) + {\color{green}{K_2}} .T. [i_\beta(n) - \hat{I_\beta}(n)]\)</p>
<p class="startli">\(\hat{E_\alpha}(n+1) = \hat{E_\alpha}(n) + T.\omega_r .\hat{E_\beta}(n) + {{\color{green}{C_4}}}.[i_\alpha(n) - \hat{I_\alpha}(n)]\)</p>
<p class="startli">\(\hat{E_\beta}(n+1) = \hat{E_\beta}(n) - T.\omega_r .\hat{E_\alpha}(n) + {{\color{green}{C_4}}}.[i_\beta(n) - \hat{I_\beta}(n)]\)</p>
</li>
</ul>
<p >With the constant \(\color{green}{C_4}\) equal to: <br  />
</p>
<p >\({{\color{green}{C_4}}} = F_2.\frac{MAX\_CURRENT}{MAX\_BEMF\_VOLTAGE}{\color{green}{K_2}}.T\) : with \({{\color{green}{C_4}}}\) = <b>Gain2</b> computed by ST Motor Control Workbench in section "Speed Sensing / Observer".</p>
<p >As shown here the tuning of the observer is allowed only via <b>Gain1</b> and <b>Gain2</b> gains which are pre-computed by ST Motor Control Workbench (as described below).</p>
<ul>
<li>ST Motor Control Workbench computation of state observer gains</li>
</ul>
<p >Initial values of gains \( {\color{green}{K_1}}\) and \( {\color{green}{K_2}}\) are based on motor parameters \(R_s\), \(L_s\) and \(T\) (which is the sampling time of the sensorless algorithm, which coincides with FOC and stator currents sampling).</p>
<p >The motor model eigenvalues could be calculated as:</p>
<p >\(e_1 = 1 - \frac{R_sT}{L_s}\)</p>
<p >\(e_2 = 1\)</p>
<p >The observer eigenvalues are placed with:</p>
<p >\(e_{1obs} = \frac{e_1}f\)</p>
<p >\(e_{2obs} = \frac{e_2}f\)</p>
<p >As a rule of the thumb, set \(f = 4\);</p>
<p >The initial values of \({\color{green}{K_1}}\) and \({\color{green}{K_2}}\) are then calculated:</p>
<p >\({\color{green}{K_1}} = \frac{(e_{1obs} + e_{2obs})  - 2}{T} - \frac{R_s}{L_s}\)</p>
<p >\({\color{green}{K_2}} = \frac{L_s(1 - e_{1obs} - e_{2obs} + e_{1obs}e_{2obs})}{T^2}\)</p>
<p >Then <b>Gain1</b> and <b>Gain2</b> are computed by applying an appropriated scaling ( \(F_1\) &amp; \(F_2\) ) and the maximum ranges of functionality defined by the following constants: <code>MAX_CURRENT</code>, <code>MAX_VOLTAGE</code> and <code>MAX_BEMF_VOLTAGE</code> (computed internally by the ST Motor Control Workbench according to the project definition).</p>
<p >This procedure is followed by the ST Motor Control Workbench to calculate proper state observer gains.</p>
<h1>Phase detection</h1>
<ul>
<li><p class="startli"><b>Phase Locked Loop (PLL)</b></p>
<p class="startli">The basic principle of this algorithm refers to a quadrature phase detector and involves the generation of an error signal from the phase difference between a couple of quadrature input signals corresponding to the couple ( \({\hat{E}_{\alpha}}\) , \({\hat{E}_{\beta}}\) ) and the corresponding quadrature feedback functions of the estimated angle \(\hat{\theta_r}\) as shown in block diagram below:<br  />
 <img src="STO_PhaseDetection_PLL.png" alt="" class="inline" title="STO Phase detection PLL Schematic Bloc"/>     <br  />
<br  />
 The error signal ( \({\epsilon}\) ) is corrected through a Proportional Integral (PI) regulator to provide the estimated speed \(\hat{\omega}_r\) and after integration the estimated electrical angle \(\hat{\theta}_r\).</p>
<p class="startli">Estimated B-EMF expression:</p>
<p class="startli">\(\hat{E}_\alpha=K_e\tilde{\omega}_r\cos{\tilde\theta_r}\)</p>
<p class="startli">\(\hat{E}_\beta=-K_e\tilde{\omega}_r\sin{\tilde{\theta_r}}\)</p>
<p class="startli">\(K_e\) represents the Back-EMF constant and \(\tilde{\omega}_r, \tilde{\theta}_r\) the pulsation and the phase angle of the estimated Back-EMF.</p>
<p class="startli">Then according to the block diagram of PLL, the math expression of the error signal \({\epsilon}\) is:</p>
<p class="startli">\({\epsilon} = -\hat{E}_\alpha.sin\hat{\theta}_r - \hat{E}_\beta.cos\hat{\theta}_r \)</p>
<p class="startli">And by replacing the expression of estimated Back-EMF it becomes: \({\epsilon} = -K_e\tilde{\omega}_r\cos{\tilde\theta_r}.sin\hat{\theta}_r + K_e\tilde{\omega}_r\sin{\tilde{\theta_r}}.cos\hat{\theta}_r \) ​ By applying the trigonometric formula: <em><b>sin(a-b) = sin(a).cos(b) - sin(b).cos(a)</b></em></p>
<p class="startli">The equation of the error can be factorized to: \({\epsilon} = K_e\tilde{\omega}_r\sin(\tilde\theta_r - \hat{\theta}_r) \)</p>
<p class="startli">With \(\tilde\theta_r\), representing the input reference while \(\hat\theta_r\) corresponds to the feedback signals (ie estimated electrical angle).</p>
<p class="startli">For small deviations between those angles, the error expression can be approximated to: \( \mathbf{{\epsilon\approx K_e\tilde{\omega}_r(\tilde\theta_r - \hat{\theta}_r) }}\)</p>
<p class="startli">A Proportional Integrator (PI) regulator is used to ensure that the estimated electrical angle \(\hat\theta_r\) converge to the phase angle of the input B-EMF signal \(\tilde\theta_r\) (by keeping the error \({\epsilon} \) = 0)</p>
</li>
<li><p class="startli"><b>CORDIC</b></p>
<p class="startli">CORDIC (COordinate Rotation DIgital Computer) is a cost-efficient successive approximation algorithm for evaluating math functions like trigonometric functions.</p>
<p class="startli">Current mcsdk library offers a software implementation of atan function : \(\hat\theta_r =atan( \frac{-\hat{E}_\beta}{\hat{E}_\alpha})\)</p>
<p class="startli">And in G4 series, in order to reduce the SW computation time a CORDIC co-processor is available supporting several mathematical functions including all trigonometric functions.</p>
<p class="startli">The electrical angle based on the estimated back-EMF components is then extracted instantaneously, but this method is more sensitive to the quality and the level of the waveforms.</p>
</li>
</ul>
<p ><a class="el" href="md_docs_rotor_speed_pos_feedback_hall.html">Next: Hall sensor feedback processing</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; 2022, ST Microelectronics &#160;<a href="http://st.com">
<img class="footer" src="ST_logo_footer.png" alt="ST Microelectronics"/>
</a>
</small></address>
</body>
</html>
